/**
 * 
 */
package org.inria.database;

import org.inria.jdbc.AutoGeneratedKeysResultSet;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;

import org.inria.jdbc.ResultSet;
import org.inria.jdbc.Statement;

/**
 * @author Alexei Troussov
 */
public class DBStatement implements java.sql.Statement
{
	@SuppressWarnings( "unused" )
	private final String TAG = DBStatement.class.getSimpleName();

	private int autoGeneratedIdGlobal;

	protected static byte[] plan_params = new byte[ Tools.PLAN_PARAMS_MAX_SIZE ];
	// byte array to store the parameters
	// type_in_db1 (1 bytes) | val1ORoffset1 (4 bytes) | type_in_db2 | val2ORoffset2 |....| data.........................
	// <------------------ param defs ----------------------------------------------------><-- String | byte[] values -->
	//
	// => number and date values are stored right after their type (on 4 bytes) in the "param defs" area
	// => byte[] and String values are stored after the "param defs" and referenced by an offset (on 4 bytes too) in the "param defs"
	protected static final int EP_PARAMS_DEF_SIZE = 5;
	protected String ep_static;
	protected int ep_params_count;
	protected int ep_params_real_size;

	private final static byte[] id_buffer = new byte[ Tools.T_SIZEINT ];
	private final static byte[] id_buffer_genkey = new byte[ 2 * Tools.T_SIZEINT ];
	protected java.sql.ResultSet res;

	private DBEngine mDB;

	protected DBStatement( DBEngine storage )
	{
		mDB = storage;
	}

	protected void prepareEP()
	{
		ep_params_real_size = 0;
		ep_params_count = 0;
	}

	protected java.sql.ResultSet query() throws SQLException
	{
		byte[] ep_params = ( ep_params_real_size == 0 ) ? null : plan_params;
		prepareEP();
		mDB.call(
				Tools.CMD_QUERY,
				ep_static,
				ep_params,
				ep_params_real_size,
				null );
		ep_params_real_size = ep_params_count * EP_PARAMS_DEF_SIZE;
		return res = new ResultSet( Integer.parseInt( ep_static ), mDB );
	}

	protected int update( int autoGeneratedKeys ) throws SQLException
	{
		byte[] ep_params = ( ep_params_real_size == 0 ) ? null : plan_params;
		int ret = 0;
		switch ( autoGeneratedKeys )
		{
		case Statement.NO_GENERATED_KEYS:
			prepareEP();
			mDB.call(
				Tools.CMD_UPDATE,
				ep_static,
				ep_params,
				ep_params_real_size,
				id_buffer );
			ret = Tools.bytea2int( id_buffer );
		break;
		case Statement.RETURN_GENERATED_KEYS:
			prepareEP();
			mDB.call(
				Tools.CMD_UPDATE_AND_GET_KEY,
				ep_static,
				ep_params,
				ep_params_real_size,
				id_buffer_genkey );
			on_AutoIdGenerated( Tools.bytea2int( id_buffer_genkey ) );
			ret = Tools.bytea2int( id_buffer_genkey, Tools.T_SIZEINT );
		break;
		default:
			throw new SQLException( "Invalid autoGeneratedKeys: " + autoGeneratedKeys );
		}
		ep_params_real_size = ep_params_count * EP_PARAMS_DEF_SIZE;
		return ret;
	}

	/**
	 * Fire a hook method in derived class to save generated id for future use
	 * @param id	The newly generated Id received from database
	 */
	protected void on_AutoIdGenerated( int id )
	{
		autoGeneratedIdGlobal = id;
	}

	@Override
	public java.sql.ResultSet executeQuery(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void close() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public java.sql.ResultSet getGeneratedKeys() throws SQLException
	{
		this.res = new AutoGeneratedKeysResultSet( autoGeneratedIdGlobal );
		return this.res;
	}

	/**
	 * Proprietary method (not compliant with JDBC spec)
	 *
	 * @return
	 * @throws SQLException
	 */
	public int getGeneratedIdGlobalKeys() throws SQLException
	{
		return this.autoGeneratedIdGlobal;
	}


	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void cancel() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void clearBatch() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void clearWarnings() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean execute(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int[] executeBatch() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public Connection getConnection() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getFetchDirection() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getFetchSize() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getMaxRows() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public java.sql.ResultSet getResultSet() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getResultSetType() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public int getUpdateCount() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean isClosed() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean isPoolable() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}
}
